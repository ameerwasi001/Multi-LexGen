use lexerGenerator::parserCombinator::*;
use lexerGenerator::tokenType::*;
use lexerGenerator::inline_function_macro;
use lexerGenerator::inline_fun;
use std::collections::HashMap;
use crate::lexer_helpers;

pub fn digit(_x: Value) -> ResType { bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|literal_parse(String::from("1"), _x), String::from("|"), |_x|literal_parse(String::from("2"), _x), _x), String::from("|"), |_x|literal_parse(String::from("3"), _x), _x), String::from("|"), |_x|literal_parse(String::from("4"), _x), _x), String::from("|"), |_x|literal_parse(String::from("5"), _x), _x), String::from("|"), |_x|literal_parse(String::from("6"), _x), _x), String::from("|"), |_x|literal_parse(String::from("7"), _x), _x), String::from("|"), |_x|literal_parse(String::from("8"), _x), _x), String::from("|"), |_x|literal_parse(String::from("9"), _x), _x), String::from("|"), |_x|literal_parse(String::from("0"), _x), _x) }
pub fn lowerAlpha(_x: Value) -> ResType { bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|literal_parse(String::from("a"), _x), String::from("|"), |_x|literal_parse(String::from("b"), _x), _x), String::from("|"), |_x|literal_parse(String::from("c"), _x), _x), String::from("|"), |_x|literal_parse(String::from("d"), _x), _x), String::from("|"), |_x|literal_parse(String::from("e"), _x), _x), String::from("|"), |_x|literal_parse(String::from("f"), _x), _x), String::from("|"), |_x|literal_parse(String::from("g"), _x), _x), String::from("|"), |_x|literal_parse(String::from("h"), _x), _x), String::from("|"), |_x|literal_parse(String::from("i"), _x), _x), String::from("|"), |_x|literal_parse(String::from("j"), _x), _x), String::from("|"), |_x|literal_parse(String::from("k"), _x), _x), String::from("|"), |_x|literal_parse(String::from("l"), _x), _x), String::from("|"), |_x|literal_parse(String::from("m"), _x), _x), String::from("|"), |_x|literal_parse(String::from("n"), _x), _x), String::from("|"), |_x|literal_parse(String::from("o"), _x), _x), String::from("|"), |_x|literal_parse(String::from("p"), _x), _x), String::from("|"), |_x|literal_parse(String::from("q"), _x), _x), String::from("|"), |_x|literal_parse(String::from("r"), _x), _x), String::from("|"), |_x|literal_parse(String::from("s"), _x), _x), String::from("|"), |_x|literal_parse(String::from("t"), _x), _x), String::from("|"), |_x|literal_parse(String::from("u"), _x), _x), String::from("|"), |_x|literal_parse(String::from("v"), _x), _x), String::from("|"), |_x|literal_parse(String::from("w"), _x), _x), String::from("|"), |_x|literal_parse(String::from("x"), _x), _x), String::from("|"), |_x|literal_parse(String::from("y"), _x), _x), String::from("|"), |_x|literal_parse(String::from("z"), _x), _x) }
pub fn upperAlpha(_x: Value) -> ResType { bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|bin_op(|_x|literal_parse(String::from("A"), _x), String::from("|"), |_x|literal_parse(String::from("B"), _x), _x), String::from("|"), |_x|literal_parse(String::from("C"), _x), _x), String::from("|"), |_x|literal_parse(String::from("D"), _x), _x), String::from("|"), |_x|literal_parse(String::from("E"), _x), _x), String::from("|"), |_x|literal_parse(String::from("F"), _x), _x), String::from("|"), |_x|literal_parse(String::from("G"), _x), _x), String::from("|"), |_x|literal_parse(String::from("H"), _x), _x), String::from("|"), |_x|literal_parse(String::from("I"), _x), _x), String::from("|"), |_x|literal_parse(String::from("J"), _x), _x), String::from("|"), |_x|literal_parse(String::from("K"), _x), _x), String::from("|"), |_x|literal_parse(String::from("L"), _x), _x), String::from("|"), |_x|literal_parse(String::from("M"), _x), _x), String::from("|"), |_x|literal_parse(String::from("N"), _x), _x), String::from("|"), |_x|literal_parse(String::from("O"), _x), _x), String::from("|"), |_x|literal_parse(String::from("P"), _x), _x), String::from("|"), |_x|literal_parse(String::from("Q"), _x), _x), String::from("|"), |_x|literal_parse(String::from("R"), _x), _x), String::from("|"), |_x|literal_parse(String::from("S"), _x), _x), String::from("|"), |_x|literal_parse(String::from("T"), _x), _x), String::from("|"), |_x|literal_parse(String::from("U"), _x), _x), String::from("|"), |_x|literal_parse(String::from("V"), _x), _x), String::from("|"), |_x|literal_parse(String::from("W"), _x), _x), String::from("|"), |_x|literal_parse(String::from("X"), _x), _x), String::from("|"), |_x|literal_parse(String::from("Y"), _x), _x), String::from("|"), |_x|literal_parse(String::from("Z"), _x), _x) }
pub fn alpha(_x: Value) -> ResType { bin_op(|_x|lowerAlpha(_x), String::from("|"), |_x|upperAlpha(_x), _x) }
pub fn keyword(_x: Value) -> ResType { bin_op(|_x|bin_op(|_x|literal_parse(String::from("if"), _x), String::from("|"), |_x|literal_parse(String::from("then"), _x), _x), String::from("|"), |_x|literal_parse(String::from("else"), _x), _x) }
pub fn whitespace(_x: Value) -> ResType { bin_op(|_x|bin_op(|_x|literal_parse(String::from("\t"), _x), String::from("|"), |_x|literal_parse(String::from("\r"), _x), _x), String::from("|"), |_x|literal_parse(String::from(" "), _x), _x) }
pub fn ident(_x: Value) -> ResType { bin_op(|_x|alpha(_x), String::from(">"), |_x|unary_op(String::from("*"), |_x|bin_op(|_x|alpha(_x), String::from("|"), |_x|digit(_x), _x), _x), _x) }
pub fn num(_x: Value) -> ResType { unary_op(String::from("+"), |_x|digit(_x), _x) }
pub fn decimal(_x: Value) -> ResType { bin_op(|_x|num(_x), String::from(">"), |_x|unary_op(String::from("*"), |_x|bin_op(|_x|literal_parse(String::from("."), _x), String::from(">"), |_x|num(_x), _x), _x), _x) }

pub fn get_unmodified_toks(_x: Value) -> Result<Vec<Token>, String> { tokens_from_rules(vec![( String::from("NUM"), (|_x|decimal(_x)) as RuleType ), ( String::from("WHITESPACE"), (|_x|whitespace(_x)) as RuleType ), ( String::from("IDENT"), (|_x|ident(_x)) as RuleType ), ( String::from("PLUS"), (|_x|literal_parse(String::from("+"), _x)) as RuleType ), ( String::from("MINUS"), (|_x|literal_parse(String::from("-"), _x)) as RuleType ), ( String::from("MUL"), (|_x|literal_parse(String::from("*"), _x)) as RuleType ), ( String::from("DIV"), (|_x|literal_parse(String::from("/"), _x)) as RuleType )], _x) }

pub fn get_toks(_x: String) -> Result<Vec<Token>, String> { 
	match get_unmodified_toks((vec![], _x)) { 
		Ok(a) => modify_token_by_condition(a, make_map(vec![("IDENT", vec![inline_fun!(_t: Token => ModifierRes := if lexer_helpers::fullyApplies(_t, |_x|keyword(_x)) { Ok(String::from("KEYWORD")) } else { Ok(String::from("")) }) as ModifierType, inline_fun!(_t: Token => ModifierRes := if lexer_helpers::isUpper(_t, 0) { Ok(String::from("UPPERIDENT")) } else { Ok(String::from("")) }) as ModifierType]), ("NUM", vec![inline_fun!(_t: Token => ModifierRes := if lexer_helpers::contains(_t, String::from("."), 1) { Ok(String::from("FLOAT")) } else { Ok(String::from("")) }) as ModifierType, inline_fun!(_t: Token => ModifierRes := if lexer_helpers::contains(_t, String::from("."), 3) { Ok(String::from("IPV4")) } else { Ok(String::from("")) }) as ModifierType, inline_fun!(_t: Token => ModifierRes := if lexer_helpers::contains(_t, String::from("."), 0) { Ok(String::from("INT")) } else { Ok(String::from("")) }) as ModifierType, inline_fun!(_t: Token => ModifierRes := if true { Err(String::from("A number must contain either 1, 0, or 3 dots")) } else { Ok(String::from("")) }) as ModifierType]), ("WHITESPACE", vec![inline_fun!(_t: Token => ModifierRes := if true { Ok(String::from("_")) } else { Ok(String::from("")) }) as ModifierType])])),
		Err(err) => return Err(err)
	}
}