import {Token} from "./token.js"
import {binOp, unaryOp, literalParse, raiseError, tokensFromRules, modifyTokenByCondition} from "./combinators.ts"
import * as lexerHelper from "./lexerHelpers.ts";

function digit(_x) { return binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>literalParse("1", _x), "|", _x=>literalParse("2", _x), _x), "|", _x=>literalParse("3", _x), _x), "|", _x=>literalParse("4", _x), _x), "|", _x=>literalParse("5", _x), _x), "|", _x=>literalParse("6", _x), _x), "|", _x=>literalParse("7", _x), _x), "|", _x=>literalParse("8", _x), _x), "|", _x=>literalParse("9", _x), _x), "|", _x=>literalParse("0", _x), _x) }
function lowerAlpha(_x) { return binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>literalParse("a", _x), "|", _x=>literalParse("b", _x), _x), "|", _x=>literalParse("c", _x), _x), "|", _x=>literalParse("d", _x), _x), "|", _x=>literalParse("e", _x), _x), "|", _x=>literalParse("f", _x), _x), "|", _x=>literalParse("g", _x), _x), "|", _x=>literalParse("h", _x), _x), "|", _x=>literalParse("i", _x), _x), "|", _x=>literalParse("j", _x), _x), "|", _x=>literalParse("k", _x), _x), "|", _x=>literalParse("l", _x), _x), "|", _x=>literalParse("m", _x), _x), "|", _x=>literalParse("n", _x), _x), "|", _x=>literalParse("o", _x), _x), "|", _x=>literalParse("p", _x), _x), "|", _x=>literalParse("q", _x), _x), "|", _x=>literalParse("r", _x), _x), "|", _x=>literalParse("s", _x), _x), "|", _x=>literalParse("t", _x), _x), "|", _x=>literalParse("u", _x), _x), "|", _x=>literalParse("v", _x), _x), "|", _x=>literalParse("w", _x), _x), "|", _x=>literalParse("x", _x), _x), "|", _x=>literalParse("y", _x), _x), "|", _x=>literalParse("z", _x), _x) }
function upperAlpha(_x) { return binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>binOp(_x=>literalParse("A", _x), "|", _x=>literalParse("B", _x), _x), "|", _x=>literalParse("C", _x), _x), "|", _x=>literalParse("D", _x), _x), "|", _x=>literalParse("E", _x), _x), "|", _x=>literalParse("F", _x), _x), "|", _x=>literalParse("G", _x), _x), "|", _x=>literalParse("H", _x), _x), "|", _x=>literalParse("I", _x), _x), "|", _x=>literalParse("J", _x), _x), "|", _x=>literalParse("K", _x), _x), "|", _x=>literalParse("L", _x), _x), "|", _x=>literalParse("M", _x), _x), "|", _x=>literalParse("N", _x), _x), "|", _x=>literalParse("O", _x), _x), "|", _x=>literalParse("P", _x), _x), "|", _x=>literalParse("Q", _x), _x), "|", _x=>literalParse("R", _x), _x), "|", _x=>literalParse("S", _x), _x), "|", _x=>literalParse("T", _x), _x), "|", _x=>literalParse("U", _x), _x), "|", _x=>literalParse("V", _x), _x), "|", _x=>literalParse("W", _x), _x), "|", _x=>literalParse("X", _x), _x), "|", _x=>literalParse("Y", _x), _x), "|", _x=>literalParse("Z", _x), _x) }
function alpha(_x) { return binOp(_x=>lowerAlpha(_x), "|", _x=>upperAlpha(_x), _x) }
function keyword(_x) { return binOp(_x=>binOp(_x=>literalParse("if", _x), "|", _x=>literalParse("then", _x), _x), "|", _x=>literalParse("else", _x), _x) }
function whitespace(_x) { return binOp(_x=>binOp(_x=>literalParse("\t", _x), "|", _x=>literalParse("\r", _x), _x), "|", _x=>literalParse(" ", _x), _x) }
function ident(_x) { return binOp(_x=>alpha(_x), ">", _x=>unaryOp("*", _x=>binOp(_x=>alpha(_x), "|", _x=>digit(_x), _x), _x), _x) }
function num(_x) { return unaryOp("+", _x=>digit(_x), _x) }
function decimal(_x) { return binOp(_x=>num(_x), ">", _x=>unaryOp("*", _x=>binOp(_x=>literalParse(".", _x), ">", _x=>num(_x), _x), _x), _x) }

const getUnmodifiedToks = (_x) => { return tokensFromRules([["NUM", _x=>decimal(_x)], ["WHITESPACE", _x=>whitespace(_x)], ["IDENT", _x=>ident(_x)], ["PLUS", _x=>literalParse("+", _x)], ["MINUS", _x=>literalParse("-", _x)], ["MUL", _x=>literalParse("*", _x)], ["DIV", _x=>literalParse("/", _x)]], _x) }
const getToks = (_x) => modifyTokenByCondition(getUnmodifiedToks([[], _x]), {"IDENT": [(_t) => lexerHelper.fullyApplies(_t, _x=>keyword(_x)) ? "KEYWORD" : null, (_t) => lexerHelper.isUpper(_t, 0) ? "UPPERIDENT" : null], "NUM": [(_t) => lexerHelper.contains(_t, ".", 1) ? "FLOAT" : null, (_t) => lexerHelper.contains(_t, ".", 3) ? "IPV4" : null, (_t) => lexerHelper.contains(_t, ".", 0) ? "INT" : null, (_t) => true ? (raiseError("A number must contain either 1, 0, or 3 dots")) : null], "WHITESPACE": [(_t) => true ? "_" : null]})

export {getToks, getUnmodifiedToks}